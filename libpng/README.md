# libpng fuzzing dataset

[Download link](https://drive.google.com/drive/folders/1PXTs9lP_GRQbKOB0OxaS5WYgI_qg8nPR)

### Dataset info

The dataset has been generated using publicly available resources from OSS-Fuzz project: https://github.com/google/oss-fuzz/tree/master/projects/libpng

* `inputs_all.tar.gz` contains **1,032,022** testcases generated by `./libpng_read_fuzzer -max_len=4096 -use_value_profile=1` fuzz target running for a few days on 25 CPUs starting separately with seed corpus and from the scratch as well.

* `inputs_interesting.tar.gz` contains **5,363** testcases which represent a minimized subset of the all inputs described above. Please note that `inputs_all` containts all the testcases from `inputs_interesting`.

* `features.tar.gz` contains **1,032,022** binary files with the names matching filenames from `inputs_all`. Each feature file represets a coverage bitmap for a testcase with the same name and is **163,840** bits long.


### Dataset size

```
$ du -hs *
20G  features
1.6G features.tar.gz
4.1G inputs_all
156M inputs_all.tar.gz
22M  inputs_interesting
504K inputs_interesting.tar.gz
```

### Corpus minimization log

```
$. /libpng_read_fuzzer.orig -merge=1 -use_value_profile=1 ./inputs_interesting ./inputs_all
INFO: Seed: 1891716711
INFO: Loaded 1 modules   (4471 inline 8-bit counters): 4471 [0x91cf30, 0x91e0a7), 
INFO: Loaded 1 PC tables (4471 PCs): 4471 [0x6ae790,0x6bff00), 
MERGE-OUTER: 1032022 files, 0 in the initial corpus
MERGE-OUTER: attempt 1
INFO: Seed: 1896645157
INFO: Loaded 1 modules   (4471 inline 8-bit counters): 4471 [0x91cf30, 0x91e0a7), 
INFO: Loaded 1 PC tables (4471 PCs): 4471 [0x6ae790,0x6bff00), 
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 1048576 bytes
MERGE-INNER: using the control file '/tmp/libFuzzerTemp.210936.txt'
MERGE-INNER: 1032022 total files; 0 processed earlier; will process 1032022 files now
#1	pulse  lim: 4 exec/s: 1 rss: 312Mb
#2	pulse  lim: 4 exec/s: 2 rss: 312Mb
#4	pulse  lim: 4 exec/s: 4 rss: 312Mb
#8	pulse  lim: 4 exec/s: 8 rss: 312Mb
#16	pulse  lim: 4 exec/s: 16 rss: 312Mb
#32	pulse  lim: 4 exec/s: 32 rss: 312Mb
#64	pulse  lim: 4 exec/s: 64 rss: 313Mb
#128	pulse  lim: 4 exec/s: 128 rss: 314Mb
#256	pulse  lim: 4 exec/s: 256 rss: 316Mb
#512	pulse  lim: 4 exec/s: 512 rss: 319Mb
#1024	pulse  lim: 4 exec/s: 1024 rss: 326Mb
#2048	pulse  lim: 4 exec/s: 2048 rss: 339Mb
#4096	pulse  lim: 4 exec/s: 4096 rss: 366Mb
#8192	pulse  lim: 4 exec/s: 8192 rss: 425Mb
#16384	pulse  lim: 4 exec/s: 8192 rss: 543Mb
#32768	pulse  lim: 4 exec/s: 10922 rss: 683Mb
#65536	pulse  lim: 4 exec/s: 16384 rss: 686Mb
#131072	pulse  lim: 4 exec/s: 6241 rss: 755Mb
#262144	pulse  lim: 4 exec/s: 3236 rss: 755Mb
#524288	pulse  lim: 4 exec/s: 4228 rss: 755Mb
MERGE-OUTER: succesfull in 1 attempt(s)
MERGE-OUTER: the control file has 83168668 bytes
MERGE-OUTER: consumed 55Mb (722Mb rss) to parse the control file
MERGE-OUTER: 5363 new files with 13596 new features added
```


## libFuzzer patch used to dump features

```
$ svn diff
Index: lib/fuzzer/FuzzerDriver.cpp
===================================================================
--- lib/fuzzer/FuzzerDriver.cpp	(revision 329601)
+++ lib/fuzzer/FuzzerDriver.cpp	(working copy)
@@ -19,6 +19,7 @@
 #include "FuzzerShmem.h"
 #include "FuzzerTracePC.h"
 #include <algorithm>
+#include <array>
 #include <atomic>
 #include <chrono>
 #include <cstdlib>
@@ -273,12 +274,31 @@
   T.detach();
 }
 
+static size_t kMaxFeature = (1 << 17) + (1 << 15);
+
+static void DumpCoverageFeature(
+    const char *InputFilePath,
+    const std::array<uint8_t, kMaxFeature / 8> &Features) {
+  std::string FilePath(InputFilePath);
+
+  FILE *Out = fopen(FilePath.c_str(), "w");
+  if (!Out) return;
+  fwrite(Features.data(), sizeof(Features[0]), Features.size(), Out);
+}
+
 int RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {
   Unit U = FileToVector(InputFilePath);
   if (MaxLen && MaxLen < U.size())
     U.resize(MaxLen);
   F->ExecuteCallback(U.data(), U.size());
-  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);
+  // F->TryDetectingAMemoryLeak(U.data(), U.size(), true);
+  std::array<uint8_t, kMaxFeature / 8> Features;
+  TPC.CollectFeatures([&](size_t Feature) {
+      size_t position = Feature / 8;
+      size_t power = Feature % 8;
+      Features[position] |= 1 << power;
+    });
+  DumpCoverageFeature(InputFilePath, Features);
   return 0;
 }


```
